import { DeployedDiamondData } from '@diamondslab/diamonds';
import { FuzzTargetFunction } from '../setup/MedusaFuzzingFramework';

/**
 * Generate a Solidity test contract for Medusa fuzzing
 * @param diamondName Name of the Diamond contract
 * @param diamondAddress Deployed Diamond contract address
 * @param targetFunctions Array of functions to fuzz
 * @param deployedData Complete deployed Diamond data
 * @returns Solidity source code as string
 */
export function generateSolidityTestContract(
	diamondName: string,
	diamondAddress: string,
	targetFunctions: FuzzTargetFunction[],
	deployedData: DeployedDiamondData,
): string {
	const contractName = `${diamondName}Test`;

	// Generate contract header
	const header = generateContractHeader(diamondName);

	// Generate contract declaration and constructor
	const contractDeclaration = generateContractDeclaration(contractName, diamondAddress);

	// Generate helper functions
	const helpers = generateHelperFunctions();

	// Generate fuzzing functions for each target
	const fuzzingFunctions = generateFuzzingFunctions(targetFunctions);

	// Generate invariants
	const invariants = generateInvariants(diamondAddress, deployedData);

	// Combine all parts
	return `${header}

${contractDeclaration}

${helpers}

${fuzzingFunctions}

${invariants}
}
`;
}

/**
 * Generate contract header with SPDX and pragma
 */
function generateContractHeader(diamondName: string): string {
	return `// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

/**
 * @title ${diamondName}Test
 * @notice Medusa fuzzing test contract for ${diamondName}
 * @dev This contract is auto-generated by MedusaFuzzingFramework
 * 
 * Fuzzing tests call functions on the deployed Diamond contract
 * and verify invariants to ensure contract integrity.
 */`;
}

/**
 * Generate contract declaration and constructor
 */
function generateContractDeclaration(contractName: string, diamondAddress: string): string {
	return `contract ${contractName} {
    // Address of the deployed Diamond contract
    address constant DIAMOND = ${diamondAddress};
    
    // Track call statistics
    uint256 public totalCalls;
    uint256 public successfulCalls;
    uint256 public failedCalls;
    
    /**
     * @notice Constructor verifies Diamond contract exists
     * @dev Reverts if Diamond contract is not deployed at expected address
     */
    constructor() {
        require(DIAMOND.code.length > 0, "Diamond not found at address");
    }`;
}

/**
 * Generate helper functions for calling Diamond
 */
function generateHelperFunctions(): string {
	return `
    /**
     * @notice Call Diamond contract with arbitrary data
     * @param selector Function selector to call
     * @param data Encoded function arguments
     * @return success Whether the call succeeded
     */
    function callDiamond(bytes4 selector, bytes memory data) internal returns (bool success) {
        totalCalls++;
        (success,) = DIAMOND.call(abi.encodePacked(selector, data));
        if (success) {
            successfulCalls++;
        } else {
            failedCalls++;
        }
        return success;
    }
    
    /**
     * @notice Helper to encode address parameter
     */
    function encodeAddress(address addr) internal pure returns (bytes memory) {
        return abi.encode(addr);
    }
    
    /**
     * @notice Helper to encode uint256 parameter
     */
    function encodeUint256(uint256 value) internal pure returns (bytes memory) {
        return abi.encode(value);
    }
    
    /**
     * @notice Helper to encode bytes parameter
     */
    function encodeBytes(bytes memory data) internal pure returns (bytes memory) {
        return abi.encode(data);
    }`;
}

/**
 * Generate fuzzing functions for each target function
 */
function generateFuzzingFunctions(targetFunctions: FuzzTargetFunction[]): string {
	let functions = '\n    // ========== Fuzzing Functions ==========\n';

	targetFunctions.forEach((target, index) => {
		const functionComment = `
    /**
     * @notice Fuzz test for ${target.facet}.${target.functionName}
     * @param addr1 Random address parameter
     * @param val1 Random uint256 parameter
     * @param data Random bytes parameter
     */`;

		const functionCode = `
    function fuzz_${index}_${target.functionName}(
        address addr1,
        uint256 val1,
        bytes memory data
    ) public {
        // Call ${target.functionName} with random inputs
        callDiamond(${target.selector}, abi.encode(addr1, val1, data));
    }`;

		functions += functionComment + functionCode + '\n';
	});

	return functions;
}

/**
 * Generate invariant functions
 */
function generateInvariants(
	diamondAddress: string,
	deployedData: DeployedDiamondData,
): string {
	// Extract facet addresses from DeployedFacets
	const deployedFacets = deployedData.DeployedFacets ?? {};
	const facetAddresses: string[] = Object.values(deployedFacets)
		.map((facet) => facet.address)
		.filter((addr): addr is string => typeof addr === 'string');

	return `
    // ========== Invariants ==========
    
    /**
     * @notice Invariant: Diamond contract must always exist
     * @dev This ensures the Diamond proxy is never destroyed
     */
    function echidna_diamond_exists() public view returns (bool) {
        return DIAMOND.code.length > 0;
    }
    
    /**
     * @notice Invariant: Facet addresses must remain valid
     * @dev Checks that key facet contracts still exist
     */
    function echidna_facets_valid() public view returns (bool) {
        ${generateFacetChecks(facetAddresses)}
        return true;
    }
    
    /**
     * @notice Invariant: Test contract maintains integrity
     * @dev Ensures the test contract itself is not corrupted
     */
    function echidna_test_integrity() public view returns (bool) {
        return address(this).code.length > 0 && DIAMOND != address(0);
    }
    
    /**
     * @notice Property: Not all calls should fail
     * @dev At least some calls should succeed during fuzzing
     */
    function echidna_some_calls_succeed() public view returns (bool) {
        // Allow this to pass if we haven't made many calls yet
        if (totalCalls < 100) return true;
        // Otherwise, require at least 1% success rate
        return successfulCalls > (totalCalls / 100);
    }`;
}

/**
 * Generate facet existence checks
 */
function generateFacetChecks(facetAddresses: string[]): string {
	if (facetAddresses.length === 0) {
		return '// No facets to check';
	}

	return facetAddresses
		.slice(0, 5) // Check up to 5 facets to avoid gas issues
		.map((addr) => `        require(address(${addr}).code.length > 0, "Facet not found");`)
		.join('\n');
}

/**
 * Generate function selector from signature
 * @param signature Function signature (e.g., "transfer(address,uint256)")
 * @returns Function selector as hex string
 */
export function getFunctionSelector(signature: string): string {
	// This is a placeholder - in actual implementation, would use ethers.js
	// to compute the selector
	const encoder = new TextEncoder();
	const data = encoder.encode(signature);
	// Simplified - in real implementation use keccak256
	return '0x' + Buffer.from(data.slice(0, 4)).toString('hex').padStart(8, '0');
}
