# Diamond ABI Loading Infrastructure

## Overview

This module provides utilities for loading and parsing Diamond ABI files in Foundry/Forge tests. The Diamond pattern uses composite ABIs that combine multiple facets, which are generated by the `@diamondslab/hardhat-diamonds` plugin and stored in `./diamond-abi/`.

## Implementation (Task 1.0)

### Components

1. **DiamondABILoader.sol** - Core library for ABI parsing
2. **DiamondABILoader.t.sol** - Comprehensive test suite
3. **foundry.toml** - File access permissions configuration

### Key Features

- ✅ Load Diamond ABI JSON files using `vm.readFile()`
- ✅ Parse function selectors from composite ABI
- ✅ Extract function signatures for call encoding
- ✅ Get detailed function information (name, selector, signature, mutability)
- ✅ Verify selectors match deployed Diamond contracts

## Usage

### Basic Example

```solidity
import {DiamondABILoader} from "../helpers/DiamondABILoader.sol";

contract MyDiamondTest is Test {
    using DiamondABILoader for string;

    function setUp() public {
        // Load the Diamond ABI
        string memory abiJson = DiamondABILoader.loadDiamondABI(
            "./diamond-abi/ExampleDiamond.json"
        );

        // Extract all selectors
        bytes4[] memory selectors = DiamondABILoader.extractSelectors(abiJson);

        // Get info for a specific function
        DiamondABILoader.FunctionInfo memory info =
            DiamondABILoader.getFunctionInfo(abiJson, "owner");

        console.log("owner() selector:");
        console.logBytes4(info.selector); // 0x8da5cb5b
    }
}
```

### Extracting Selectors (Task 1.3)

```solidity
string memory abiJson = DiamondABILoader.loadDiamondABI("./diamond-abi/ExampleDiamond.json");
bytes4[] memory selectors = DiamondABILoader.extractSelectors(abiJson);

// Returns array like: [0xa217fddf, 0xee0c950c, 0xc47ea632, ...]
// One selector for each function in the composite ABI
```

### Extracting Signatures (Task 1.4)

```solidity
string memory abiJson = DiamondABILoader.loadDiamondABI("./diamond-abi/ExampleDiamond.json");
string[] memory signatures = DiamondABILoader.extractSignatures(abiJson);

// Returns array like:
// ["DEFAULT_ADMIN_ROLE()", "diamondCut(tuple[],address,bytes)", "owner()", ...]
```

### Getting Function Info

```solidity
string memory abiJson = DiamondABILoader.loadDiamondABI("./diamond-abi/ExampleDiamond.json");
DiamondABILoader.FunctionInfo memory info =
    DiamondABILoader.getFunctionInfo(abiJson, "transferOwnership");

// Returns struct with:
// - name: "transferOwnership"
// - signature: "transferOwnership(address)"
// - selector: 0xf2fde38b
// - isView: false
// - exists: true
```

### Verifying Deployment (Task 1.5)

```solidity
// Extract selectors from ABI file
bytes4[] memory abiSelectors = DiamondABILoader.extractSelectors(abiJson);

// Get selectors from deployed Diamond via DiamondLoupe
IDiamondLoupe diamond = IDiamondLoupe(diamondAddress);
bytes4[] memory deployedSelectors = diamond.facetFunctionSelectors(facetAddress);

// Verify they match
bool matches = DiamondABILoader.verifySelectorsMatch(abiSelectors, deployedSelectors);
assertTrue(matches, "ABI selectors should match deployed Diamond");
```

## Technical Implementation

### vm.parseJson() Usage (Task 1.1)

The implementation uses Foundry's `vm.parseJson()` cheatcode to parse the JSON ABI file:

```solidity
// Parse function type
bytes memory typeBytes = vm.parseJson(abiJson, ".abi[0].type");
string memory entryType = abi.decode(typeBytes, (string)); // "function", "event", etc.

// Parse function name
bytes memory nameBytes = vm.parseJson(abiJson, ".abi[0].name");
string memory name = abi.decode(nameBytes, (string));
```

### Empty Array Detection

**Important**: `vm.parseJson()` returns 0-length bytes when accessing an element of an empty array, rather than throwing an error:

```solidity
// For a function with no inputs: {"inputs": []}
bytes memory firstInput = vm.parseJson(abiJson, ".abi[5].inputs[0].type");
// Returns: bytes with length == 0 (not a revert!)

if (firstInput.length > 0) {
    // Has inputs
} else {
    // Empty inputs array
}
```

### Building Function Signatures

Signatures are built by concatenating the function name with parameter types:

```solidity
// For: transferOwnership(address)
signature = "transferOwnership"; // Start with name
signature = string(abi.encodePacked(signature, "("));
signature = string(abi.encodePacked(signature, "address")); // Add param type
signature = string(abi.encodePacked(signature, ")"));
// Result: "transferOwnership(address)"

// Compute selector
bytes4 selector = bytes4(keccak256(bytes(signature))); // 0xf2fde38b
```

### Tuple Handling

Complex types like tuples are extracted directly from the `type` field:

```solidity
// For: diamondCut(tuple[],address,bytes)
// The ABI stores "tuple[]" as the type string
// No need to expand tuple components for selector computation
```

## File Access Configuration

Foundry requires explicit file access permissions in `foundry.toml`:

```toml
fs_permissions = [
    { access = "read", path = "./diamond-abi" },
    { access = "read", path = "./artifacts" },
    { access = "write", path = "./test-assets/test-output" }
]
```

## Limitations and Considerations

### Performance

- **Iteration Limit**: Currently scans up to 300 ABI entries
  - ExampleDiamond has ~200 entries (events + functions)
  - Increase limit if needed for larger Diamonds

- **Gas Usage**: Functions iterate through entire ABI
  - `extractSelectors()`: ~5.6M gas for 23 functions
  - `extractSignatures()`: ~5.8M gas for 23 functions
  - `getFunctionInfo()`: ~2.3M gas (stops when found)
  - Use caching in `setUp()` to avoid repeated parsing

### Signature Accuracy

- ✅ Handles functions with no parameters: `owner()`
- ✅ Handles functions with basic types: `transferOwnership(address)`
- ✅ Handles functions with multiple params: `grantRole(bytes32,address)`
- ✅ Handles complex types: `diamondCut(tuple[],address,bytes)`
- ⚠️ **Tuples are not expanded** - uses `tuple` keyword as-is
  - This matches Solidity's canonical signature format
  - Selectors computed correctly

### Type Handling

The library extracts the `type` field directly from the ABI:

- Basic types: `address`, `uint256`, `bytes32`, `bool`, etc.
- Arrays: `address[]`, `uint256[]`, `tuple[]`, etc.
- Fixed arrays: `bytes32[3]`, `address[2]`, etc.
- Tuples: `tuple`, `tuple[]` (not expanded to components)

## Fallback Strategy (Task 1.7)

If `vm.parseJson()` has issues in the future, alternative approaches include:

### Option 1: vm.ffi() with jq

```solidity
string[] memory inputs = new string[](3);
inputs[0] = "jq";
inputs[1] = "-r";
inputs[2] = ".abi[] | select(.type == \"function\") | .name";
bytes memory result = vm.ffi(inputs);
```

**Pros**: More flexible JSON querying  
**Cons**: Requires external `jq` tool, slower

### Option 2: Hardhat Script Pre-processing

Generate a Solidity file with selector constants:

```solidity
// Generated by: npx hardhat run scripts/generate-selectors.ts
library ExampleDiamondSelectors {
    bytes4 constant OWNER = 0x8da5cb5b;
    bytes4 constant TRANSFER_OWNERSHIP = 0xf2fde38b;
    // ...
}
```

**Pros**: No runtime parsing, type-safe  
**Cons**: Manual regeneration needed, less flexible

### Option 3: Manual ABI Parsing

Implement custom JSON parser in Solidity (complex, not recommended).

## Test Coverage

All functionality is validated by `DiamondABILoader.t.sol`:

- ✅ `test_LoadDiamondABI()` - File loading (Task 1.2)
- ✅ `test_ExtractSelectors()` - Selector extraction (Task 1.3)
- ✅ `test_ExtractSignatures()` - Signature extraction (Task 1.4)
- ✅ `test_SelectorSignatureCorrespondence()` - Selector/signature matching
- ✅ `test_GetFunctionInfo_Owner()` - View function info
- ✅ `test_GetFunctionInfo_TransferOwnership()` - Non-view function info
- ✅ `test_GetFunctionInfo_GrantRole()` - Multi-param function
- ✅ `test_GetFunctionInfo_NonExistent()` - Missing function handling
- ✅ `test_VerifySelectorsMatch_Success()` - Verification success (Task 1.5)
- ✅ `test_VerifySelectorsMatch_Failure()` - Verification failure (Task 1.5)
- ✅ `test_ComprehensiveABIExtraction()` - Full ABI extraction

**Result**: 11/11 tests passing

## Integration with Diamond Testing

This infrastructure enables:

1. **Deployment Verification**: Compare ABI selectors with `DiamondLoupe.facetFunctionSelectors()`
2. **Fuzzing Setup**: Extract selectors for targeted fuzzing of specific functions
3. **Call Encoding**: Use signatures to encode function calls dynamically
4. **Facet Discovery**: Identify which functions belong to which facets

## Next Steps

- Task 2.0: Create Hardhat deployment script for ExampleDiamond
- Task 3.0: Develop `DiamondFuzzBase` library using this ABI loader
- Task 4.0: Implement fuzzing tests for ExampleAccessControl functions

## References

- Foundry Book: [vm.parseJson()](https://book.getfoundry.sh/cheatcodes/parse-json)
- Foundry Book: [vm.readFile()](https://book.getfoundry.sh/cheatcodes/read-file)
- Foundry Book: [File Permissions](https://book.getfoundry.sh/cheatcodes/fs)
- ERC-2535 Diamond Standard: [EIP-2535](https://eips.ethereum.org/EIPS/eip-2535)
- Diamond Loupe: [IDiamondLoupe.sol](https://github.com/mudgen/diamond-3-hardhat/blob/main/contracts/interfaces/IDiamondLoupe.sol)
