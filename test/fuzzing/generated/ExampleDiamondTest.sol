// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

/**
 * @title ExampleDiamondTest
 * @notice Medusa fuzzing test contract for ExampleDiamond
 * @dev This contract is auto-generated by MedusaFuzzingFramework
 * 
 * Fuzzing tests call functions on the deployed Diamond contract
 * and verify invariants to ensure contract integrity.
 */

contract ExampleDiamondTest {
    // Address of the deployed Diamond contract
    address constant DIAMOND = 0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0;
    
    // Track call statistics
    uint256 public totalCalls;
    uint256 public successfulCalls;
    uint256 public failedCalls;
    
    /**
     * @notice Constructor verifies Diamond contract exists
     * @dev Reverts if Diamond contract is not deployed at expected address
     */
    constructor() {
        require(DIAMOND.code.length > 0, "Diamond not found at address");
    }


    /**
     * @notice Call Diamond contract with arbitrary data
     * @param selector Function selector to call
     * @param data Encoded function arguments
     * @return success Whether the call succeeded
     */
    function callDiamond(bytes4 selector, bytes memory data) internal returns (bool success) {
        totalCalls++;
        (success,) = DIAMOND.call(abi.encodePacked(selector, data));
        if (success) {
            successfulCalls++;
        } else {
            failedCalls++;
        }
        return success;
    }
    
    /**
     * @notice Helper to encode address parameter
     */
    function encodeAddress(address addr) internal pure returns (bytes memory) {
        return abi.encode(addr);
    }
    
    /**
     * @notice Helper to encode uint256 parameter
     */
    function encodeUint256(uint256 value) internal pure returns (bytes memory) {
        return abi.encode(value);
    }
    
    /**
     * @notice Helper to encode bytes parameter
     */
    function encodeBytes(bytes memory data) internal pure returns (bytes memory) {
        return abi.encode(data);
    }


    // ========== Fuzzing Functions ==========

    /**
     * @notice Fuzz test for ExampleOwnershipFacet.transferOwnership
     * @param addr1 Random address parameter
     * @param val1 Random uint256 parameter
     * @param data Random bytes parameter
     */
    function fuzz_0_transferOwnership(
        address addr1,
        uint256 val1,
        bytes memory data
    ) public {
        // Call transferOwnership with random inputs
        callDiamond(0xf2fde38b, abi.encode(addr1, val1, data));
    }

    /**
     * @notice Fuzz test for ExampleOwnershipFacet.owner
     * @param addr1 Random address parameter
     * @param val1 Random uint256 parameter
     * @param data Random bytes parameter
     */
    function fuzz_1_owner(
        address addr1,
        uint256 val1,
        bytes memory data
    ) public {
        // Call owner with random inputs
        callDiamond(0x8da5cb5b, abi.encode(addr1, val1, data));
    }

    /**
     * @notice Fuzz test for ExampleUpgradeFacet.isDeployed
     * @param addr1 Random address parameter
     * @param val1 Random uint256 parameter
     * @param data Random bytes parameter
     */
    function fuzz_2_isDeployed(
        address addr1,
        uint256 val1,
        bytes memory data
    ) public {
        // Call isDeployed with random inputs
        callDiamond(0xc52046de, abi.encode(addr1, val1, data));
    }

    /**
     * @notice Fuzz test for ExampleUpgradeFacet.getSelector
     * @param addr1 Random address parameter
     * @param val1 Random uint256 parameter
     * @param data Random bytes parameter
     */
    function fuzz_3_getSelector(
        address addr1,
        uint256 val1,
        bytes memory data
    ) public {
        // Call getSelector with random inputs
        callDiamond(0x034899bc, abi.encode(addr1, val1, data));
    }

    /**
     * @notice Fuzz test for ExampleAccessControl.hasRole
     * @param addr1 Random address parameter
     * @param val1 Random uint256 parameter
     * @param data Random bytes parameter
     */
    function fuzz_4_hasRole(
        address addr1,
        uint256 val1,
        bytes memory data
    ) public {
        // Call hasRole with random inputs
        callDiamond(0x00000000, abi.encode(addr1, val1, data));
    }



    // ========== Invariants ==========
    
    /**
     * @notice Invariant: Diamond contract must always exist
     * @dev This ensures the Diamond proxy is never destroyed
     */
    function echidna_diamond_exists() public view returns (bool) {
        return DIAMOND.code.length > 0;
    }
    
    /**
     * @notice Invariant: Facet addresses must remain valid
     * @dev Checks that key facet contracts still exist
     */
    function echidna_facets_valid() public view returns (bool) {
                require(address(0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512).code.length > 0, "Facet not found");
        require(address(0xa513E6E4b8f2a923D98304ec87F64353C4D5C853).code.length > 0, "Facet not found");
        require(address(0x2279B7A0a67DB372996a5FaB50D91eAA73d2eBe6).code.length > 0, "Facet not found");
        require(address(0x8A791620dd6260079BF849Dc5567aDC3F2FdC318).code.length > 0, "Facet not found");
        require(address(0x610178dA211FEF7D417bC0e6FeD39F05609AD788).code.length > 0, "Facet not found");
        return true;
    }
    
    /**
     * @notice Invariant: Test contract maintains integrity
     * @dev Ensures the test contract itself is not corrupted
     */
    function echidna_test_integrity() public view returns (bool) {
        return address(this).code.length > 0 && DIAMOND != address(0);
    }
    
    /**
     * @notice Property: Not all calls should fail
     * @dev At least some calls should succeed during fuzzing
     */
    function echidna_some_calls_succeed() public view returns (bool) {
        // Allow this to pass if we haven't made many calls yet
        if (totalCalls < 100) return true;
        // Otherwise, require at least 1% success rate
        return successfulCalls > (totalCalls / 100);
    }
}
