import { expect } from 'chai';
import { ethers } from 'hardhat';
import {
	DefenderDiamondDeployer,
	DefenderDiamondDeployerConfig,
	DeploymentStatus,
} from '../../../scripts/setup/DefenderDiamondDeployer';
import { SignerWithAddress } from '@nomicfoundation/hardhat-ethers/signers';

describe('Error Handling Unit Tests', function () {
	let signer: SignerWithAddress;
	let validConfig: DefenderDiamondDeployerConfig;

	beforeEach(async function () {
		const signers = await ethers.getSigners();
		signer = signers[0];

		validConfig = {
			diamondName: 'ExampleDiamond',
			networkName: 'hardhat',
			chainId: 31337,
			apiKey: 'test_api_key',
			apiSecret: 'test_api_secret',
			relayerAddress: signer.address,
			autoApprove: false,
			viaType: 'EOA',
			via: signer.address,
			provider: ethers.provider,
			signer: signer,
			configFilePath: 'diamonds/ExampleDiamond/examplediamond.config.json',
		};
	});

	describe('Configuration Validation Errors', function () {
		it('should handle missing required fields gracefully', async function () {
			const configs = [
				{ ...validConfig, apiKey: '' },
				{ ...validConfig, apiSecret: '' },
				{ ...validConfig, relayerAddress: '' },
				{ ...validConfig, diamondName: '' },
				{ ...validConfig, networkName: '' },
			];

			for (const config of configs) {
				try {
					await DefenderDiamondDeployer.getInstance(
						config as DefenderDiamondDeployerConfig,
					);
					expect.fail('Should have thrown validation error');
				} catch (error) {
					expect(error).to.be.instanceOf(Error);
					// Check that error message contains relevant information about the missing field
					expect((error as Error).message).to.be.a('string');
				}
			}
		});

		it('should handle invalid viaType values', async function () {
			const invalidViaTypes = ['invalid', 'safe', 'eoa', 'SAFE', 'EOA_INVALID'];

			for (const viaType of invalidViaTypes) {
				try {
					const config = { ...validConfig, viaType: viaType as any };
					await DefenderDiamondDeployer.getInstance(config);
					expect.fail(`Should have thrown error for viaType: ${viaType}`);
				} catch (error) {
					expect(error).to.be.instanceOf(Error);
					// Check that error message contains information about viaType
					expect((error as Error).message).to.be.a('string');
				}
			}
		});

		it('should handle invalid addresses', async function () {
			const invalidAddresses = [
				'invalid_address',
				'0x123',
				'0xinvalid',
				'not_an_address',
				'',
			];

			for (const address of invalidAddresses) {
				try {
					const config = { ...validConfig, relayerAddress: address };
					await DefenderDiamondDeployer.getInstance(config);
					expect.fail(`Should have thrown error for address: ${address}`);
				} catch (error) {
					expect(error).to.be.instanceOf(Error);
					// Should contain validation error message
				}
			}
		});

		it('should handle invalid autoApprove values', async function () {
			const invalidValues = ['invalid_boolean', 0, 1, 'true', 'false'];

			for (const value of invalidValues) {
				try {
					const config = { ...validConfig, autoApprove: value as any };
					await DefenderDiamondDeployer.getInstance(config);
					// Most of these might not throw since they're converted to boolean
					// This test is mainly checking that the code doesn't crash
				} catch (error) {
					expect(error).to.be.instanceOf(Error);
				}
			}
		});
	});

	describe('Network Configuration Errors', function () {
		it('should handle non-existent network configuration files', function () {
			const nonExistentNetworks = [
				'nonexistent',
				'invalid_network',
				'test_network_that_does_not_exist',
			];

			for (const network of nonExistentNetworks) {
				expect(() => {
					DefenderDiamondDeployer.loadNetworkConfig(network);
				}).to.throw('Network configuration file not found');
			}
		});

		it('should handle malformed network configuration files', function () {
			// This would require creating malformed config files or mocking fs
			// For now, we'll test the error handling logic
			expect(() => {
				// This should throw since we don't have this network config
				DefenderDiamondDeployer.loadNetworkConfig('malformed_config');
			}).to.throw();
		});
	});

	describe('Environment Variable Errors', function () {
		let originalEnv: any;

		beforeEach(function () {
			originalEnv = { ...process.env };
		});

		afterEach(function () {
			process.env = originalEnv;
		});

		it('should handle missing environment variables', function () {
			// Clear all defender environment variables
			process.env.DEFENDER_API_KEY = '';
			process.env.DEFENDER_API_SECRET = '';
			process.env.DEFENDER_RELAYER_ADDRESS = '';

			// The createConfigFromEnv doesn't validate - it just creates config with empty values
			// The validation happens during getInstance
			const config = DefenderDiamondDeployer.createConfigFromEnv({
				diamondName: 'ExampleDiamond',
				networkName: 'hardhat',
			});
			expect(config.apiKey).to.equal('');
		});

		it('should handle invalid environment variable values', function () {
			process.env.DEFENDER_API_KEY = 'valid_key';
			process.env.DEFENDER_API_SECRET = 'valid_secret';
			process.env.DEFENDER_RELAYER_ADDRESS = 'invalid_address';

			expect(() => {
				DefenderDiamondDeployer.createConfigFromEnv({
					diamondName: 'TestDiamond',
					networkName: 'mainnet',
				});
			}).to.not.throw(); // The validation happens during getInstance, not createConfigFromEnv
		});

		it('should handle invalid gas limit in environment', function () {
			process.env.DEFENDER_API_KEY = 'valid_key';
			process.env.DEFENDER_API_SECRET = 'valid_secret';
			process.env.DEFENDER_RELAYER_ADDRESS = signer.address;
			process.env.DEFENDER_GAS_LIMIT = 'invalid_number';

			const config = DefenderDiamondDeployer.createConfigFromEnv({
				diamondName: 'ExampleDiamond',
				networkName: 'hardhat',
			});

			// Should use default values when parsing fails
			expect(config.autoApprove).to.be.a('boolean');
			expect(config.verbose).to.be.a('boolean');
		});
	});

	describe('Deployment Error Scenarios', function () {
		it('should handle deployment failures gracefully', async function () {
			// Create a config with invalid network to simulate deployment failure
			const config = {
				...validConfig,
				networkName: 'invalid_network',
				chainId: 999999, // Non-existent chain
			};

			try {
				const deployer = await DefenderDiamondDeployer.getInstance(config);
				// This might throw during deployment, not getInstance
				await deployer.deployDiamond();
				expect.fail('Should have thrown deployment error');
			} catch (error) {
				expect(error).to.be.instanceOf(Error);
				// Error should be meaningful
				expect((error as Error).message).to.be.a('string');
				expect((error as Error).message.length).to.be.greaterThan(0);
			}
		});

		it('should handle concurrent deployment attempts', async function () {
			const deployer = await DefenderDiamondDeployer.getInstance(validConfig);

			// Start two deployments concurrently
			const deployment1Promise = deployer.deployDiamond();
			const deployment2Promise = deployer.deployDiamond();

			try {
				const results = await Promise.allSettled([deployment1Promise, deployment2Promise]);

				// Both should either succeed or handle concurrency gracefully
				results.forEach((result, index) => {
					if (result.status === 'rejected') {
						console.log(`Deployment ${index + 1} rejected:`, result.reason);
					}
				});

				// At least one should succeed or both should handle concurrency
				const successCount = results.filter((r) => r.status === 'fulfilled').length;
				expect(successCount).to.be.at.least(0); // We expect graceful handling
			} catch (error) {
				// Deployment might fail in test environment, that's OK
				expect(error).to.be.instanceOf(Error);
			}
		});
	});

	describe('Recovery and Resilience', function () {
		it('should handle network interruptions', async function () {
			// This is difficult to test without actually interrupting network
			// We'll test the error handling structure
			const deployer = await DefenderDiamondDeployer.getInstance(validConfig);

			// Verify that the deployer has error handling capabilities
			expect(deployer).to.respondTo('getDeploymentStatus');
			const initialStatus = deployer.getDeploymentStatus();

			// Status could be NOT_STARTED or FAILED if previous tests affected it
			expect([DeploymentStatus.NOT_STARTED, DeploymentStatus.FAILED]).to.include(
				initialStatus,
			);
		});

		it('should maintain consistent state after errors', async function () {
			const deployer = await DefenderDiamondDeployer.getInstance(validConfig);

			const initialStatus = deployer.getDeploymentStatus();
			// Status could be NOT_STARTED or FAILED if previous tests affected it
			expect([DeploymentStatus.NOT_STARTED, DeploymentStatus.FAILED]).to.include(
				initialStatus,
			);

			try {
				// Attempt deployment (might fail in test environment)
				await deployer.deployDiamond();
			} catch (error) {
				// After a failed deployment, status should be meaningful
				const postErrorStatus = deployer.getDeploymentStatus();
				expect([
					DeploymentStatus.NOT_STARTED,
					DeploymentStatus.FAILED,
					DeploymentStatus.COMPLETED,
				]).to.include(postErrorStatus);
			}
		});
	});

	describe('Error Message Quality', function () {
		it('should provide descriptive error messages', async function () {
			const testCases = [
				{
					config: { ...validConfig, apiKey: '' },
					expectedContent: ['required', 'key'],
				},
				{
					config: { ...validConfig, viaType: 'invalid' as any },
					expectedContent: ['viaType', 'Safe', 'EOA'],
				},
				{
					config: { ...validConfig, via: '' },
					expectedContent: ['via', 'required'],
				},
			];

			for (const testCase of testCases) {
				try {
					await DefenderDiamondDeployer.getInstance(testCase.config);
					expect.fail('Should have thrown validation error');
				} catch (error) {
					const message = (error as Error).message.toLowerCase();

					testCase.expectedContent.forEach((content) => {
						expect(message).to.include(
							content.toLowerCase(),
							`Error message should contain "${content}" for config: ${JSON.stringify(testCase.config)}`,
						);
					});
				}
			}
		});
	});
});
