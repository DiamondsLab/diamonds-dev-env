# Product Requirements Document: Echidna Fuzzing Integration

## Introduction/Overview

This feature adds Echidna fuzzing test capabilities to the `@diamondslab/diamonds_dev_env` project used to develop the DiamondsLab node modules which are used to manage ERC-2535 Diamond proxy contract systems. The node modules are included in the form of git submodules in the `./packages/` directory and to integrate functionlity needed by projects that utilize these node modules. This includes a DevContainer base platform git submodule repo in the `.devcontainer` directory.

Echidna is a property-based fuzzing tool for Ethereum smart contracts that helps discover security vulnerabilities, edge cases, and invariant violations.

The integration will create a reusable framework that allows developers using the Diamonds module and related modules to write and run Echidna fuzzing tests against their Diamond proxy contracts. The framework will leverage the existing `LocalDiamondDeployer` class and diamond-abi generation via the Diamonds module (@diamondslab/diamonds) in conjunction with Hardhat-Diamonds module (@diamondslab/hardhat-diamonds) to ensure fuzzing tests accurately reflect the deployed contract state.

**Problem this solves:** Currently, projects that use the Diamonds module lack automated property-based testing capabilities. Echidna fuzzing will help discover:

- Security vulnerabilities in the Diamond proxy pattern implementation
- Invariant violations across facet upgrades and diamond cuts
- State consistency issues across multiple facet interactions
- Edge cases that traditional unit/integration tests might miss

## Goals

1. Build a reusable Echidna test infrastructure that projects using the Diamonds module can extend
2. Successfully run at least one Echidna fuzzing test against a deployed Diamond contract
3. Provide comprehensive documentation enabling developers to create their own fuzzing tests
4. Ensure fuzzing tests properly utilize the Diamonds module's deployment and ABI generation features
5. Discover and validate security properties and invariants in the Diamond proxy pattern

## User Stories

**As a smart contract developer using the Diamonds module, I want to:**

- Run Echidna fuzzing tests against my Diamond contracts to discover security vulnerabilities
- Leverage existing Diamond deployment infrastructure without writing custom deployment code
- Access generated diamond-abi files in my fuzzing tests to ensure accurate function selectors
- Write custom invariants and properties specific to my facets and business logic
- Have clear examples and documentation to guide me in writing effective fuzzing tests

**As a Diamonds module maintainer, I want to:**

- Provide a standardized way for users to add fuzzing tests to their projects
- Ensure fuzzing tests validate core Diamond proxy functionality (cuts, lookups, facet management)
- Make it easy for contributors to add new fuzzing test scenarios
- Maintain separation between traditional tests and fuzzing tests for clarity

## Functional Requirements

### Core Infrastructure

1. **FR-1:** The system must create a dedicated directory structure for Echidna tests separate from existing test directories (e.g., `echidna/`).

2. **FR-2:** The system must provide a base Echidna test contract template that demonstrates how to:
   - Deploy a Diamond contract using `LocalDiamondDeployer`
   - Access the deployed Diamond address
   - Import and use the generated diamond-abi
   - Define property/invariant functions that Echidna can test

3. **FR-3:** The system must include npm scripts to run Echidna tests (e.g., `npm run echidna` or `yarn echidna`).

4. **FR-4:** The system must provide an Echidna configuration file (`echidna.yaml` or `echidna.config.yaml`) with sensible defaults for:
   - Test contract location
   - Deployment parameters
   - Number of test sequences
   - Corpus directory
   - Coverage reporting

### Diamond Integration

5. **FR-5:** Echidna test contracts must utilize the `LocalDiamondDeployer` class to deploy Diamond contracts with a fresh deployment for each fuzzing campaign.

6. **FR-6:** The test infrastructure must automatically locate and use the correct diamond-abi files generated by the Diamonds module by referencing the `diamond-abi/` directory.

7. **FR-7:** Echidna tests must have access to deployment data via `getDeployedDiamondData()` to retrieve:
   - Diamond contract address
   - Deployed facet addresses
   - Diamond configuration details

8. **FR-8:** The system must support deploying Diamond contracts with custom configurations specified in the test setup.

### Example Implementation

9. **FR-9:** The system must include at least one complete working example that demonstrates:
   - Deploying a Diamond contract in an Echidna test
   - Testing an invariant property (e.g., "Diamond owner cannot be zero address")
   - Accessing facet functions through the diamond-abi
   - Validating state consistency across operations

10. **FR-10:** Example tests must include comments explaining:
    - How the deployment works
    - What property is being tested
    - How to add additional properties
    - How to interpret Echidna output

### Documentation

11. **FR-11:** The system must provide a comprehensive README or documentation file (`ECHIDNA.md` or section in main README) covering:
    - Prerequisites (Echidna installation)
    - How to run Echidna tests
    - How to write new fuzzing tests
    - How to interpret results
    - Troubleshooting common issues

12. **FR-12:** Documentation must include code snippets showing:
    - Basic test contract structure
    - How to deploy different Diamond configurations
    - How to access specific facets
    - How to define meaningful invariants

13. **FR-13:** Documentation must explain the relationship between:
    - `deploymentsPath` and test contract deployment
    - `diamond-abi` directory and test contract imports
    - `LocalDiamondDeployer` and Echidna test setup

### Tooling & Scripts

14. **FR-14:** The system must provide helper scripts (if needed) to:
    - Set up the Echidna test environment
    - Clean up deployment artifacts between test runs
    - Generate initial test templates

15. **FR-15:** The npm script for running Echidna must properly configure environment variables and paths needed by the Diamonds module.

## Non-Goals (Out of Scope)

1. **Automated CI/CD Integration:** The initial version will run standalone. CI/CD integration can be added later.

2. **Integration with existing unit/integration test suite:** Echidna tests will remain separate and not run as part of `npm test`.

3. **Pre-deployed contract testing:** The initial version will only support fresh deployments, not fuzzing against existing deployment records.

4. **Fuzzing specific example contracts:** The focus is on building the framework and one proof-of-concept example, not testing all example contracts.

5. **Symbolic execution or formal verification:** This feature is limited to Echidna fuzzing, not other verification tools.

6. **Custom Echidna installation or packaging:** Users must install Echidna independently; we won't bundle it.

7. **Mutation testing or differential fuzzing:** Advanced fuzzing techniques are out of scope for the initial implementation.

## Design Considerations

### Directory Structure

```
project-root/
├── echidna/
│   ├── contracts/          # Echidna test contracts
│   │   └── DiamondFuzzTest.sol
│   ├── setup/              # Deployment helpers (if needed)
│   ├── config/
│   │   └── echidna.yaml    # Echidna configuration
│   └── README.md           # Echidna-specific documentation
├── packages/
│   └── diamonds/
└── scripts/
    └── setup/
        └── LocalDiamondDeployer.ts  # Existing deployer
```

### Test Contract Pattern

```solidity
// Example structure
contract DiamondFuzzTest {
    Diamond diamond;

    constructor() {
        // Use LocalDiamondDeployer logic here
        // Deploy diamond with test configuration
    }

    // Echidna invariant (must always return true)
    function echidna_owner_not_zero() public view returns (bool) {
        return diamond.owner() != address(0);
    }
}
```

### Configuration Approach

- Use `echidna.yaml` for Echidna-specific settings
- Reference `hardhat.config.ts` settings where appropriate
- Allow test contracts to override deployment configurations

## Technical Considerations

### Dependencies

- **Echidna:** Users must be included in the DevContainer
- **Hardhat:** Leverage existing Hardhat environment and configuration
- **TypeScript/Solidity:** Test contracts in Solidity, deployment logic may need TypeScript to Solidity bridge

### Deployment Strategy

- Each Echidna test contract should deploy its own Diamond instance in the constructor or setup function
- Use `LocalDiamondDeployer` pattern but adapt for Solidity context (may need Solidity helper contracts)
- Ensure deployment records are written to appropriate directories for debugging

### ABI Access

- Echidna test contracts must import generated diamond-abi as Solidity interfaces
- May need to generate Solidity interface files from JSON ABI
- Ensure ABI generation happens before Echidna tests run

### Integration Points

- `LocalDiamondDeployer.ts` - Study this for deployment logic
- `hardhat.config.ts` - Reference for Diamond configurations
- `diamond-abi/` - Generated ABIs must be accessible to test contracts
- `diamonds/<DiamondContractName>/` - Deployment records for debugging

### Challenges & Solutions

1. **Challenge:** Bridging TypeScript deployment logic to Solidity test contracts
   - **Solution:** Create Solidity helper contracts that mirror `LocalDiamondDeployer` functionality, or use Hardhat's scripting within Echidna setup

2. **Challenge:** Accessing generated diamond-abi in Echidna tests
   - **Solution:** Generate Solidity interface files from JSON ABI as part of build process

3. **Challenge:** Managing deployment artifacts during fuzzing
   - **Solution:** Use temporary directories or clean-up scripts between runs

## Success Metrics

### Primary Success Criteria

1. **Working Example:** At least one complete Echidna fuzzing test successfully runs against a deployed Diamond contract and validates an invariant.

2. **Documentation Quality:** A developer unfamiliar with Echidna can follow the documentation and successfully:
   - Install prerequisites
   - Run the example fuzzing test
   - Write a new custom fuzzing test for their own facet
   - Interpret Echidna output

### Secondary Success Metrics

3. **Code Reusability:** The framework should reduce boilerplate - developers can create new fuzzing tests by copying a template and modifying <50 lines of code.

4. **Deployment Accuracy:** Echidna tests deploy Diamond contracts with the exact same configuration and facet composition as `LocalDiamondDeployer` produces.

5. **Discovery Capability:** The example test should demonstrate Echidna's ability to discover at least one meaningful property (even if trivial, like owner != zero address).

## Open Questions

1. **Solidity Deployment:** How should we handle the TypeScript-to-Solidity bridge for `LocalDiamondDeployer`? Options:
   - Rewrite deployment logic in Solidity for Echidna tests
   - Use Hardhat scripts in Echidna setup phase (if supported)
   - Create hybrid approach with minimal Solidity deployment helpers

2. **ABI Interface Generation:** Should we auto-generate Solidity interface files from diamond-abi JSON, or should developers manually create them?

3. **Diamond Configuration:** How should Echidna tests specify which facets to include in the Diamond deployment?
   - Hardcoded in test contract
   - Read from config file
   - Mirror existing hardhat.config.ts settings

4. **Corpus Management:** Where should Echidna store its corpus and coverage data? Should it be gitignored?

5. **Multiple Diamond Contracts:** Should the framework support fuzzing multiple different Diamond contracts in the same test run, or one at a time?

6. **Stateful vs Stateless:** Should tests primarily focus on:
   - Stateful fuzzing (sequences of operations)
   - Stateless property testing (individual function properties)
   - Both (provide examples of each)
