# Product Requirements Document: Forge Fuzzing Tests with Diamond ABI

## Introduction/Overview

This feature enables Foundry Forge fuzzing tests to interact with ERC-2535 Diamond contracts using the custom Diamond ABI generated by the `@diamondslab/hardhat-diamonds` and the `@diamondslab/diamonds` module. Currently, the project has a hybrid Hardhat-Foundry setup, but Forge tests cannot directly utilize the Diamond ABI from `./diamond-abi/ExampleDiamond.json`, which is essential for testing the complete Diamond proxy with all its facets.

**Problem:** Standard Forge tests use ABIs from the `out/` directory, but Diamond contracts require a composite ABI that reflects the actual deployment configuration, including all facet function selectors. Without this, Forge tests cannot properly interact with the Diamond proxy as a complete system.

**Goal:** Create a reusable Solidity library/helper that loads the Diamond ABI and enables Forge fuzzing tests to validate Diamond contract behavior, including function selector routing, access control, state consistency, and gas efficiency.

## Goals

1. **Enable Forge to use Diamond ABI:** Load and utilize `./diamond-abi/ExampleDiamond.json` in Forge tests instead of standard ABIs from `out/`
2. **Deploy Diamond via Hardhat for testing:** Use existing Hardhat deployment scripts to deploy Diamond to local chain before Forge tests run
3. **Create reusable testing library:** Build abstract helper that can be used across multiple Diamond projects
4. **Implement comprehensive fuzzing:** Test function selector routing, access control, state consistency, and gas optimization
5. **Deliver within 1 week:** Provide working solution for immediate testing needs

## User Stories

**As a smart contract developer:**

- I want to write Forge fuzzing tests that interact with my Diamond contract, so I can validate complex scenarios with randomized inputs
- I want my fuzzing tests to use the actual Diamond ABI, so they reflect the real deployment configuration
- I want a simple setup helper, so I don't have to recreate Diamond deployment logic in every test file
- I want to test all facets through the Diamond proxy, so I can ensure selector routing works correctly

**As a QA engineer:**

- I want comprehensive fuzzing coverage of Diamond functions, so I can catch edge cases and vulnerabilities
- I want to validate access control across all facets, so unauthorized actions are prevented
- I want to ensure state consistency after arbitrary function sequences, so the Diamond remains in a valid state

**As a DevOps engineer:**

- I want tests that can run in CI/CD pipelines, so Diamond contracts are validated on every commit
- I want clear test output showing what was fuzzed, so failures are easy to diagnose

## Functional Requirements

### Core Requirements

1. **Diamond ABI Loading**
   - FR1.1: The system MUST read and parse `./diamond-abi/ExampleDiamond.json` at test runtime
   - FR1.2: The system MUST extract all function selectors and signatures from the Diamond ABI
   - FR1.3: The system MUST make these functions callable from Solidity test contracts

2. **Diamond Deployment Integration**
   - FR2.1: The system MUST deploy the ExampleDiamond using Hardhat deployment scripts before Forge tests execute
   - FR2.2: The system MUST capture and store the deployed Diamond contract address
   - FR2.3: The system MUST make the deployed Diamond address accessible to all Forge test contracts
   - FR2.4: The system MUST support deploying to Hardhat's local network (for Forge --fork-url)

3. **Reusable Testing Library**
   - FR3.1: The system MUST provide an abstract base contract (e.g., `DiamondFuzzBase.sol`) that other test contracts can inherit
   - FR3.2: The base contract MUST expose helper functions for common Diamond interactions
   - FR3.3: The library MUST be framework-agnostic enough to work with different Diamond implementations
   - FR3.4: The library MUST include documentation and usage examples

4. **Comprehensive Fuzzing Tests**
   - FR4.1: Tests MUST validate that function selectors route to correct facets
   - FR4.2: Tests MUST fuzz access control functions (role grants, revokes, renounces) with random addresses and roles
   - FR4.3: Tests MUST verify state consistency by checking invariants after random function call sequences
   - FR4.4: Tests MUST measure and assert gas consumption stays within acceptable bounds
   - FR4.5: Tests MUST use Foundry's `vm.assume()` to constrain fuzz inputs to valid ranges

5. **Integration with Existing Setup**
   - FR5.1: The solution MUST work with the existing hybrid Hardhat-Foundry setup
   - FR5.2: The solution MUST NOT break existing Hardhat tests
   - FR5.3: The solution MUST integrate with existing `yarn forge:test` scripts
   - FR5.4: The solution MUST use the existing `foundry.toml` configuration

## Non-Goals (Out of Scope)

1. **NOT in scope:** Porting Diamond deployment logic to pure Solidity (we use Hardhat for deployment)
2. **NOT in scope:** Testing non-Diamond contracts or standard proxy patterns
3. **NOT in scope:** Creating a UI or dashboard for test results (use standard Forge output)
4. **NOT in scope:** Automated fuzzing of every possible facet (focus on ExampleAccessControl initially)
5. **NOT in scope:** Formal verification or symbolic execution (use Foundry's standard fuzzing)
6. **NOT in scope:** Cross-chain or multi-network deployment testing
7. **NOT in scope:** Upgrading or modifying the `@diamondslab/hardhat-diamonds` module itself

## Design Considerations

### Proposed Architecture

```
test/foundry/helpers/
├── DiamondFuzzBase.sol          # Abstract base contract for Diamond fuzzing tests
├── DiamondABILoader.sol         # Helper to load Diamond ABI (if possible in Solidity)
└── README.md                    # Usage documentation

test/foundry/fuzz/
├── DiamondAccessControlFuzz.t.sol  # Fuzzing tests for access control
├── DiamondRouting.t.sol            # Tests for selector routing
└── DiamondInvariants.t.sol         # Invariant tests for state consistency

scripts/foundry/
└── deploy-diamond-for-tests.sh     # Shell script to deploy Diamond before tests
```

### Workflow

1. **Pre-test setup:** Run Hardhat script to deploy Diamond to local chain
2. **Save deployment info:** Store Diamond address in a known location (e.g., `.forge-diamond-address`)
3. **Forge tests:** Read deployment address, interact with Diamond using function signatures from ABI
4. **Post-test:** Optionally clean up local chain state

### Technical Approach

Since Solidity cannot directly parse JSON, the Diamond ABI will be handled via one of these approaches:

- **Option A (Recommended):** Use Forge's `vm.parseJson()` cheatcode to read Diamond ABI at test time
- **Option B:** Pre-process Diamond ABI into Solidity interface during build step
- **Option C:** Use `vm.ffi()` to call a script that returns function selectors

## Technical Considerations

### Dependencies

- Foundry with forge-std (already installed)
- Hardhat with @diamondslab/hardhat-diamonds (already configured)
- Node.js and Yarn for running Hardhat scripts
- jq or similar for JSON parsing (if using vm.ffi approach)

### Known Constraints

- Forge cannot natively parse JSON, requires cheatcodes or preprocessing
- Diamond deployment requires Hardhat, cannot be done purely in Forge
- Local Hardhat node must be running for forked tests
- Diamond ABI is generated at compile time, not available during Forge compilation

### Integration Points

- Must work with existing `yarn compile` which generates Diamond ABI
- Must integrate with `yarn forge:test` workflow
- Should support CI/CD environments (GitHub Actions, etc.)
- Must handle cleanup between test runs

### Security Considerations

- Fuzzing should not expose private keys or sensitive data
- Test accounts should use deterministic addresses (Hardhat defaults)
- Diamond deployment should use test-only configuration

## Success Metrics

### Immediate Success (Week 1)

1. ✅ Diamond deployment script successfully deploys to local chain
2. ✅ Forge test can read deployed Diamond address
3. ✅ Forge test can call at least one Diamond function using ABI
4. ✅ At least one fuzzing test runs successfully with 256+ runs
5. ✅ Access control fuzzing catches unauthorized access attempts

### Long-term Success

1. Test coverage includes all ExampleAccessControl functions
2. Fuzzing tests run in < 30 seconds for 1000 runs
3. Zero false positives in fuzzing results
4. Gas usage tracking shows no unexpected spikes
5. Other developers successfully use the helper library for new tests

### Quality Metrics

- Code coverage: Aim for 80%+ of Diamond facet functions tested
- Fuzzing depth: Minimum 256 runs per test, ideally 1000+
- Documentation: Complete README with examples
- Reusability: Base contract used by at least 3 different test files

## Timeline

**Week 1 (Urgent Delivery)**

**Day 1-2: Setup & Infrastructure**

- Create directory structure (`test/foundry/helpers/`, `test/foundry/fuzz/`)
- Implement Hardhat deployment script for local testing
- Create mechanism to save/load Diamond address for Forge tests

**Day 3-4: Base Library**

- Implement `DiamondFuzzBase.sol` with Diamond interaction helpers
- Test Diamond ABI loading approach (vm.parseJson or alternative)
- Create first working example test that calls Diamond function

**Day 5-6: Fuzzing Tests**

- Implement access control fuzzing tests (FR4.2)
- Implement selector routing validation (FR4.1)
- Implement state consistency checks (FR4.3)
- Add gas profiling (FR4.4)

**Day 7: Documentation & Polish**

- Write comprehensive README with usage examples
- Add inline documentation to all helper functions
- Test in CI/CD environment
- Create demo/example showing usage

## Open Questions

1. **ABI Loading Method:** Which approach should we prioritize for loading Diamond ABI in Forge tests?
   - Need to evaluate performance and reliability of vm.parseJson() vs preprocessing

2. **Test Isolation:** How should we handle state cleanup between fuzz runs?
   - Use vm.snapshot/revertTo or redeploy Diamond each time?

3. **Hardhat Node Management:** Should the deployment script start/stop Hardhat node automatically?
   - Or assume developer runs `npx hardhat node` separately?

4. **Configuration:** Should Diamond address and deployment info be stored in a file or environment variable?
   - Consider security implications and CI/CD compatibility

5. **Error Handling:** How should tests handle Diamond deployment failures?
   - Fail fast or retry with different configuration?

## Implementation Notes

### For the Developer

- Start with the simplest approach that works (prefer vm.parseJson if available)
- Create a working prototype before optimizing
- Write tests for the test helpers themselves
- Use existing ExampleDiamond deployment as reference
- Leverage existing Foundry integration tests as templates
- Consider edge cases: empty roles, zero addresses, overflow scenarios

### File Locations

- Base helper: `test/foundry/helpers/DiamondFuzzBase.sol`
- First fuzzing test: `test/foundry/fuzz/AccessControlFuzz.t.sol`
- Deployment script: `scripts/test-deploy-diamond.ts` (TypeScript) or `scripts/foundry/deploy-for-tests.sh` (Shell)
- Documentation: `test/foundry/helpers/README.md`

### Testing Strategy

1. Unit test the helper library functions
2. Integration test Diamond deployment
3. Validate fuzzing with known inputs first
4. Scale up to full randomized fuzzing
5. Run in CI to catch regressions

---

**Document Version:** 1.0  
**Created:** November 14, 2025  
**Status:** Awaiting Implementation  
**Priority:** Urgent (1 week delivery)
